<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>Der Arrayparameter ist als "InAttribute" oder "OutAttribute" gekennzeichnet.</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Parameter '{1}', der ein Array ist und entweder ein System.Runtime.InteropServices.InAttribute oder ein System.Runtime.InteropServices.OutAttribute aufweist.</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>In der Windows-Runtime müssen Arrayparameter entweder ReadOnlyArray oder WriteOnlyArray aufweisen.</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text3" xml:space="preserve">
    <value>Entfernen Sie diese Attribute, oder ersetzen Sie sie bei Bedarf durch das entsprechende Windows-Runtime Attribut.</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Brief" xml:space="preserve">
    <value>Arrayparameter als "out" und ReadOnlyArray markiert</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Ausgabeparameter '{1}', der ein Array ist, das jedoch das Attribut ReadOnlyArray aufweist.</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text2" xml:space="preserve">
    <value>In der Windows-Runtime sind die Inhalte von Ausgabearrays beschreibbar. Entfernen Sie das Attribut aus '{1}'.</value>
  </data>
  <data name="ArrayParamMarkedBoth_Brief" xml:space="preserve">
    <value>Der Arrayparameter hat sowohl ReadOnlyArray als auch WriteOnlyArray markiert.</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Parameter '{1}', der ein Array ist und sowohl ReadOnlyArray als auch WriteOnlyArray aufweist.</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text2" xml:space="preserve">
    <value>In der Windows-Runtime müssen die Parameter des Inhaltsarrays entweder lesbar oder beschreibbar sein. Entfernen Sie eines der Attribute aus '{1}'.</value>
  </data>
  <data name="ArrayParamNotMarked_Brief" xml:space="preserve">
    <value>Der Arrayparameter ist nicht als ReadOnlyArray oder WriteOnlyArray gekennzeichnet.</value>
  </data>
  <data name="ArrayParamNotMarked_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Parameter '{1}', bei dem es sich um ein Array handelt.</value>
  </data>
  <data name="ArrayParamNotMarked_Text2" xml:space="preserve">
    <value>In der Windows-Runtime muss der Inhalt von Arrayparametern entweder lesbar oder beschreibbar sein; wenden Sie entweder ReadOnlyArray oder WriteOnlyArray auf '{1}' an.</value>
  </data>
  <data name="ClassConstructorRule_Brief" xml:space="preserve">
    <value>Klassenkonstruktorregel</value>
  </data>
  <data name="ClassConstructorRule_Text" xml:space="preserve">
    <value>Klassen dürfen nicht mehrere Konstruktoren derselben Stelligkeit in der Windows-Runtime aufweisen. Die Klasse {0} hat mehrere {1}-Stelligkeitskonstruktoren.</value>
  </data>
  <data name="DisjointNamespaceRule_Brief" xml:space="preserve">
    <value>Der Namespace ist vom Hauptnamespace (winmd) getrennt.</value>
  </data>
  <data name="DisjointNamespaceRule_Text1" xml:space="preserve">
    <value>Ein öffentlicher Typ hat einen Namespace ('{1}'), der kein gemeinsames Präfix mit anderen Namespaces ('{0}') gemeinsam hat.</value>
    <comment>{1} and {0} will be some user-defined keyword</comment>
  </data>
  <data name="DisjointNamespaceRule_Text2" xml:space="preserve">
    <value>Alle Typen innerhalb einer Windows-Metadatendatei müssen in einem Unternamespace des Namespace vorhanden sein, der vom Dateinamen impliziert wird.</value>
    <comment>"sub namespace" means a namespace defined within another namespace</comment>
  </data>
  <data name="GenericTypeRule_Brief" xml:space="preserve">
    <value>Die Klasse (oder Schnittstelle) ist generisch.</value>
  </data>
  <data name="GenericTypeRule_Text" xml:space="preserve">
    <value>Der Typ {0} ist generisch, Windows-Runtime Typen dürfen nicht generisch sein.</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="JaggedArrayRule_Brief" xml:space="preserve">
    <value>Es wurde eine Arraysignatur mit gezacktem Array gefunden. Dies ist kein gültiger WinRT-Typ.</value>
  </data>
  <data name="JaggedArrayRule_Text" xml:space="preserve">
    <value>Die Methode {0} weist ein geschachteltes Array vom Typ {1} in der Signatur auf. Arrays in Windows-Runtime Methodensignatur können nicht geschachtelt werden.</value>
  </data>
  <data name="MultiDimensionalArrayRule_Brief" xml:space="preserve">
    <value>Es wurde eine Arraysignatur mit einem mehrdimensionalen Array gefunden. Dies ist kein gültiger Windows-Runtime Typ.</value>
  </data>
  <data name="MultiDimensionalArrayRule_Text" xml:space="preserve">
    <value>Die Methode '{0}' hat ein mehrdimensionales Array vom Typ '{1}' in der Signatur. Arrays in Windows-Runtime Methodensignaturen müssen eindimensional sein.</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>Als Standard sollte nur eine Überladung festgelegt werden.</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text1" xml:space="preserve">
    <value>In klasse {2}: Mehrere {0}-Parameterüberladungen von '{1}' sind mit Windows.Foundation.Metadata.DefaultOverloadAttribute ausgestattet.</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text2" xml:space="preserve">
    <value>Das Attribut kann nur auf eine Überladung der Methode angewendet werden.</value>
  </data>
  <data name="NamespacesDifferByCase_Brief" xml:space="preserve">
    <value>Namespacenamen dürfen sich nicht nur nach Fall unterscheiden.</value>
  </data>
  <data name="NamespacesDifferByCase_Text" xml:space="preserve">
    <value>Es wurden mehrere Namespaces mit dem Namen "'{0}';" gefunden. Namespacenamen dürfen sich nicht nur in der Windows-Runtime</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="NeedDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>Mehrere Überladungen ohne DefaultOverload-Attribut.</value>
  </data>
  <data name="NeedDefaultOverloadAttribute_Text" xml:space="preserve">
    <value>In Klasse {2}: Für die {0}-Parameterüberladungen von {1} muss genau eine Methode als Standardüberladung angegeben werden, indem sie mit Windows.Foundation.Metadata.DefaultOverloadAttribute decoratiert wird.</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>Der Parameter (kein Arraytyp) ist als "InAttribute" oder "OutAttribute" gekennzeichnet.</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat parameter '{1}' mit system.Runtime.InteropServices.InAttribute oder System.Runtime.InteropServices.OutAttribute.Windows-Runtime unterstützt keine Kennzeichnung von Parametern mit System.Runtime.InteropServices.InAttribute oder System.Runtime.InteropServices.OutAttribute.</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>Entfernen Sie ggf. System.Runtime.InteropServices.InAttribute, und ersetzen Sie stattdessen System.Runtime.InteropServices.OutAttribute durch den out-Modifizierer.</value>
  </data>
  <data name="NonArrayMarked_Brief" xml:space="preserve">
    <value>Nichtarrayparameter mit ReadOnlyArray oder WriteOnlyArray markiert</value>
  </data>
  <data name="NonArrayMarked_Text1" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Parameter '{1}', der kein Array ist und entweder ein ReadOnlyArray-Attribut oder ein WriteOnlyArray-Attribut aufweist.</value>
  </data>
  <data name="NonArrayMarked_Text2" xml:space="preserve">
    <value>Windows-Runtime unterstützt keine Kennzeichnung von Nichtarrayparametern mit ReadOnlyArray oder WriteOnlyArray.</value>
  </data>
  <data name="NonWinRTInterface_Brief" xml:space="preserve">
    <value>Ungültige geerbte Schnittstelle</value>
  </data>
  <data name="NonWinRTInterface_Text" xml:space="preserve">
    <value>Windows-Runtime Komponententyp kann {0} die Schnittstelle nicht {1} implementieren, da die Schnittstelle keine gültige Windows-Runtime Schnittstelle ist.</value>
  </data>
  <data name="NoPublicTypesRule_Brief" xml:space="preserve">
    <value>Es sind keine öffentlichen Typen definiert.</value>
  </data>
  <data name="NoPublicTypesRule_Text" xml:space="preserve">
    <value>Windows-Runtime Komponenten müssen mindestens einen öffentlichen Typ aufweisen.</value>
  </data>
  <data name="OperatorOverloadedRule_Brief" xml:space="preserve">
    <value>Operatorüberladung verfügbar gemacht</value>
  </data>
  <data name="OperatorOverloadedRule_Text" xml:space="preserve">
    <value>{0} ist eine Operatorüberladung. Verwaltete Typen können keine Operatorüberladungen in der Windows-Runtime verfügbar machen.</value>
  </data>
  <data name="ParameterNamedValueRule_Brief" xml:space="preserve">
    <value>Regel für benannten Parameterwert</value>
  </data>
  <data name="ParameterNamedValueRule_Text" xml:space="preserve">
    <value>Der Parametername {1} in der Methode {0} ist mit dem Parameternamen des Rückgabewerts identisch, der im generierten C#/WinRT-Interop verwendet wird. Anderen Parameternamen verwenden</value>
  </data>
  <data name="PrivateGetterRule_Brief" xml:space="preserve">
    <value>Die Eigenschaft muss einen öffentlichen Getter aufweisen.</value>
  </data>
  <data name="PrivateGetterRule_Text" xml:space="preserve">
    <value>Die Eigenschaft '{0}' hat keine öffentliche Gettermethode. Windows-Runtime unterstützt keine eigenschaften nur für Setter.</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="RefParameterFound_Brief" xml:space="preserve">
    <value>Parameter als Verweis übergeben</value>
  </data>
  <data name="RefParameterFound_Text" xml:space="preserve">
    <value>Die Methode '{0}' hat einen Parameter, '{1}' als "ref" markiert ist; Verweisparameter sind in Windows-Runtime nicht zulässig.</value>
  </data>
  <data name="StructHasConstFieldRule_Brief" xml:space="preserve">
    <value>Konstantenfeld in Struktur</value>
  </data>
  <data name="StructHasConstFieldRule_Text" xml:space="preserve">
    <value>Die Struktur {0} weist ein konstantes Feld auf. Konstanten können nur für Windows-Runtime Enumerationen verwendet werden.</value>
  </data>
  <data name="StructHasInvalidFieldRule_Brief" xml:space="preserve">
    <value>Ungültiges Feld in Struktur</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text1" xml:space="preserve">
    <value>Die Struktur {0} hat ein Feld vom Typ {1}; {1} ist kein gültiger Windows-Runtime Feldtyp.</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text2" xml:space="preserve">
    <value>Jedes Feld in einer Windows-Runtime Struktur kann nur UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, String, Enum oder selbst eine Struktur sein.</value>
  </data>
  <data name="StructHasPrivateFieldRule_Brief" xml:space="preserve">
    <value>Privates Feld in Struktur</value>
  </data>
  <data name="StructHasPrivateFieldRule_Text" xml:space="preserve">
    <value>Die Struktur {0} weist ein nicht öffentliches Feld auf. Alle Felder müssen für Windows-Runtime Strukturen öffentlich sein.</value>
  </data>
  <data name="StructWithNoFieldsRule_Brief" xml:space="preserve">
    <value>Leere Strukturregel</value>
  </data>
  <data name="StructWithNoFieldsRule_Text" xml:space="preserve">
    <value>Die Struktur {0} enthält keine öffentlichen Felder. Windows-Runtime Müssen mindestens ein öffentliches Feld enthalten.</value>
  </data>
  <data name="UnimplementedInterface_Brief" xml:space="preserve">
    <value>Die Klasse implementiert eine Schnittstelle falsch.</value>
  </data>
  <data name="UnimplementedInterface_Text" xml:space="preserve">
    <value>Die '{0}' implementiert die Schnittstelle '{1}' nicht ordnungsgemäß, da '{2}' fehlt oder nicht öffentlich ist.</value>
  </data>
  <data name="UnsealedClassRule_Brief" xml:space="preserve">
    <value>Klasse ist nicht versiegelt</value>
  </data>
  <data name="UnsealedClassRule_Text" xml:space="preserve">
    <value>Das Exportieren nicht versiegelter Typen wird in CsWinRT nicht unterstützt. Markieren Sie den Typ {0} als versiegelt.</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Brief" xml:space="preserve">
    <value>Nicht unterstützter Typ wird verfügbar machen</value>
  </data>
  <data name="UnsupportedTypeRule_Text1" xml:space="preserve">
    <value>Der Member '{0}' weist den Typ '{1}' in der Signatur auf.</value>
    <comment>{0} and {1} will be user-defined keywords</comment>
  </data>
  <data name="UnsupportedTypeRule_Text2" xml:space="preserve">
    <value>Der Typ '{1}' ist kein gültiger Windows-Runtime Typ.</value>
    <comment>{1} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Text3" xml:space="preserve">
    <value>Der Typ (oder seine generischen Parameter) implementiert jedoch Schnittstellen, die gültige Windows-Runtime Typen sind.</value>
  </data>
  <data name="UnsupportedTypeRule_Text4" xml:space="preserve">
    <value>Erwägen Sie, den Typ "{1} in der Membersignatur in einen der folgenden Typen aus System.Collections.Generic zu ändern: {2}.</value>
    <comment>{1} and {2} will be keywords (types) from DotNet</comment>
  </data>
</root>