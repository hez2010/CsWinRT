<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>标记为 InAttribute 或 OutAttribute 的数组参数</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>方法'{0}'具有作为数组的参数 '{1}'，该参数具有 System.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute。</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>在Windows 运行时中，数组参数必须具有 ReadOnlyArray 或 WriteOnlyArray。</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text3" xml:space="preserve">
    <value>如有必要，请删除这些属性或将其替换为适当的Windows 运行时属性。</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Brief" xml:space="preserve">
    <value>标记为 "out" 和 ReadOnlyArray 的数组参数</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text1" xml:space="preserve">
    <value>方法'{0}'具有输出参数'{1}'，该参数是数组，但具有 ReadOnlyArray 特性。</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text2" xml:space="preserve">
    <value>在Windows 运行时中，输出数组的内容是可写的。请从'{1}'中删除属性。</value>
  </data>
  <data name="ArrayParamMarkedBoth_Brief" xml:space="preserve">
    <value>数组参数标记为 ReadOnlyArray 和 WriteOnlyArray</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text1" xml:space="preserve">
    <value>方法'{0}'具有参数 '{1}'，该参数是数组，同时具有 ReadOnlyArray 和 WriteOnlyArray。</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text2" xml:space="preserve">
    <value>在Windows 运行时中，内容数组参数必须可读或可写，请从'{1}'中删除其中一个属性。</value>
  </data>
  <data name="ArrayParamNotMarked_Brief" xml:space="preserve">
    <value>数组参数未标记为 ReadOnlyArray 或 WriteOnlyArray 方式</value>
  </data>
  <data name="ArrayParamNotMarked_Text1" xml:space="preserve">
    <value>方法'{0}'具有作为数组的参数'{1}'。</value>
  </data>
  <data name="ArrayParamNotMarked_Text2" xml:space="preserve">
    <value>在Windows 运行时中，数组参数的内容必须可读或可写;请将 ReadOnlyArray 或 WriteOnlyArray 应用于 '{1}'。</value>
  </data>
  <data name="ClassConstructorRule_Brief" xml:space="preserve">
    <value>类构造函数规则</value>
  </data>
  <data name="ClassConstructorRule_Text" xml:space="preserve">
    <value>类在Windows 运行时中不能有多个相同 arity 的构造函数，类{0}具有多个{1} arity 构造函数</value>
  </data>
  <data name="DisjointNamespaceRule_Brief" xml:space="preserve">
    <value>命名空间与主(winmd)命名空间不相邻</value>
  </data>
  <data name="DisjointNamespaceRule_Text1" xml:space="preserve">
    <value>公共类型具有命名空间 ('{1}')，该命名空间没有与其他命名空间 ('{0}')共享公共前缀。</value>
    <comment>{1} and {0} will be some user-defined keyword</comment>
  </data>
  <data name="DisjointNamespaceRule_Text2" xml:space="preserve">
    <value>Windows 元数据文件中的所有类型都必须存在于文件名隐含的命名空间的子命名空间中。</value>
    <comment>"sub namespace" means a namespace defined within another namespace</comment>
  </data>
  <data name="GenericTypeRule_Brief" xml:space="preserve">
    <value>类(或接口)是泛型的</value>
  </data>
  <data name="GenericTypeRule_Text" xml:space="preserve">
    <value>类型{0}是泛型的，Windows 运行时类型不能是泛型的</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="JaggedArrayRule_Brief" xml:space="preserve">
    <value>发现具有交错数组的数组签名，该数组不是有效的 WinRT 类型</value>
  </data>
  <data name="JaggedArrayRule_Text" xml:space="preserve">
    <value>方法{0}的签名中有{1}类型的嵌套数组;Windows 运行时方法签名中的数组不能嵌套</value>
  </data>
  <data name="MultiDimensionalArrayRule_Brief" xml:space="preserve">
    <value>找到多维数组的数组签名，该数组不是有效的Windows 运行时类型</value>
  </data>
  <data name="MultiDimensionalArrayRule_Text" xml:space="preserve">
    <value>方法'{0}'的签名中有一个'{1}'类型的多维数组;Windows 运行时方法签名中的数组必须是一维的</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>只应指定一个重载默认值</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text1" xml:space="preserve">
    <value>在类{2}中： 使用 Windows.Foundation.Metadata.DefaultOverloadAttribute 修饰'{1}'的多个{0}参数重载。</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text2" xml:space="preserve">
    <value>该属性只能应用于方法的一个重载。</value>
  </data>
  <data name="NamespacesDifferByCase_Brief" xml:space="preserve">
    <value>命名空间名称不能仅区分大小写</value>
  </data>
  <data name="NamespacesDifferByCase_Text" xml:space="preserve">
    <value>找到多个具有名称'{0}'的命名空间;命名空间名称不能仅在Windows 运行时中区分大小写</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="NeedDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>在没有 DefaultOverload 属性的情况下发现多个重载</value>
  </data>
  <data name="NeedDefaultOverloadAttribute_Text" xml:space="preserve">
    <value>在类{2}中： {1}的{0}参数重载必须正好有一种方法指定为默认重载，方法是使用 Windows.Foundation.Metadata.DefaultOverloadAttribute 进行修饰</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>参数(不是标记为 InAttribute 或 OutAttribute)数组类型</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>方法'{0}'具有 system.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute.Windows 运行时 的参数'{1}'不支持使用 System.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute 标记参数。</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>请考虑删除 System.Runtime.InteropServices.InAttribute，改用 "out" 修饰符替换 System.Runtime.InteropServices.OutAttribute。</value>
  </data>
  <data name="NonArrayMarked_Brief" xml:space="preserve">
    <value>用 ReadOnlyArray 或 WriteOnlyArray 标记的非数组参数</value>
  </data>
  <data name="NonArrayMarked_Text1" xml:space="preserve">
    <value>方法'{0}'具有参数'{1}'，该参数不是数组，并且具有 ReadOnlyArray 特性或 WriteOnlyArray 特性。</value>
  </data>
  <data name="NonArrayMarked_Text2" xml:space="preserve">
    <value>Windows 运行时不支持用 ReadOnlyArray 或 WriteOnlyArray 标记非数组参数。</value>
  </data>
  <data name="NonWinRTInterface_Brief" xml:space="preserve">
    <value>继承的接口无效</value>
  </data>
  <data name="NonWinRTInterface_Text" xml:space="preserve">
    <value>Windows 运行时组件类型{0}无法实现接口{1}，因为该接口不是有效的Windows 运行时接口</value>
  </data>
  <data name="NoPublicTypesRule_Brief" xml:space="preserve">
    <value>未定义公共类型</value>
  </data>
  <data name="NoPublicTypesRule_Text" xml:space="preserve">
    <value>Windows 运行时组件必须至少有一个公共类型</value>
  </data>
  <data name="OperatorOverloadedRule_Brief" xml:space="preserve">
    <value>运算符重载已公开</value>
  </data>
  <data name="OperatorOverloadedRule_Text" xml:space="preserve">
    <value>{0}是运算符重载，托管类型不能在Windows 运行时中公开运算符重载</value>
  </data>
  <data name="ParameterNamedValueRule_Brief" xml:space="preserve">
    <value>参数命名值规则</value>
  </data>
  <data name="ParameterNamedValueRule_Text" xml:space="preserve">
    <value>方法{0}中{1}的参数名称与生成的 C#/WinRT 互操作中使用的返回值参数名称相同;使用其他参数名称</value>
  </data>
  <data name="PrivateGetterRule_Brief" xml:space="preserve">
    <value>属性必须具有 public getter</value>
  </data>
  <data name="PrivateGetterRule_Text" xml:space="preserve">
    <value>属性'{0}'没有公共 getter 方法。Windows 运行时不支持仅 setter 属性。</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="RefParameterFound_Brief" xml:space="preserve">
    <value>引用传递的参数</value>
  </data>
  <data name="RefParameterFound_Text" xml:space="preserve">
    <value>方法'{0}'具有标记为"ref"的参数'{1}';不允许在Windows 运行时中使用引用参数</value>
  </data>
  <data name="StructHasConstFieldRule_Brief" xml:space="preserve">
    <value>结构中的常量字段</value>
  </data>
  <data name="StructHasConstFieldRule_Text" xml:space="preserve">
    <value>结构{0}具有常量字段 - 常量只能出现在Windows 运行时枚举上。</value>
  </data>
  <data name="StructHasInvalidFieldRule_Brief" xml:space="preserve">
    <value>结构中的字段无效</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text1" xml:space="preserve">
    <value>结构{0}具有{1}类型的字段;{1}不是有效的Windows 运行时字段类型。</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text2" xml:space="preserve">
    <value>Windows 运行时结构中的每个字段只能是 UInt8、Int16、UInt16、Int32、UInt32、Int64、UInt64、Single、Double、Boolean、String、Enum 或其自身的结构。</value>
  </data>
  <data name="StructHasPrivateFieldRule_Brief" xml:space="preserve">
    <value>结构中的专用字段</value>
  </data>
  <data name="StructHasPrivateFieldRule_Text" xml:space="preserve">
    <value>结构{0}具有非公共字段。对于Windows 运行时结构，所有字段都必须是公共的。</value>
  </data>
  <data name="StructWithNoFieldsRule_Brief" xml:space="preserve">
    <value>空结构规则</value>
  </data>
  <data name="StructWithNoFieldsRule_Text" xml:space="preserve">
    <value>结构{0}不包含公共字段。Windows 运行时结构必须至少包含一个公共字段。</value>
  </data>
  <data name="UnimplementedInterface_Brief" xml:space="preserve">
    <value>类错误地实现接口</value>
  </data>
  <data name="UnimplementedInterface_Text" xml:space="preserve">
    <value>类'{0}'未正确实现接口'{1}'，因为成员'{2}'缺失或为非公共</value>
  </data>
  <data name="UnsealedClassRule_Brief" xml:space="preserve">
    <value>类未密封</value>
  </data>
  <data name="UnsealedClassRule_Text" xml:space="preserve">
    <value>CsWinRT 中不支持导出未密封的类型，请将类型{0}标记为密封</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Brief" xml:space="preserve">
    <value>公开不受支持的类型</value>
  </data>
  <data name="UnsupportedTypeRule_Text1" xml:space="preserve">
    <value>成员'{0}'的签名中有类型'{1}'。</value>
    <comment>{0} and {1} will be user-defined keywords</comment>
  </data>
  <data name="UnsupportedTypeRule_Text2" xml:space="preserve">
    <value>类型'{1}'不是有效的Windows 运行时类型。</value>
    <comment>{1} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Text3" xml:space="preserve">
    <value>然而，类型(或其泛型参数)实现有效的Windows 运行时类型的接口。</value>
  </data>
  <data name="UnsupportedTypeRule_Text4" xml:space="preserve">
    <value>请考虑将成员签名中的类型"{1}"从 System.Collections.Generic 更改为以下类型之一： {2}。</value>
    <comment>{1} and {2} will be keywords (types) from DotNet</comment>
  </data>
</root>